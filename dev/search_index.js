var documenterSearchIndex = {"docs":
[{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"EditURL = \"../../../examples/md_SE.jl\"","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"This section shows how to perform monotone decomposition on a noised random curve generated from Gaussian process.","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"using MonotoneDecomposition\nusing Plots\nusing Random","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Firstly, generate random data from Gaussian process with square kernel,","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Random.seed!(7)\nx, y, x0, y0 = gen_data(100, 0.5, \"SE_1\")","category":"page"},{"location":"examples/md_SE/#With-Cubic-B-splines","page":"Monotone Decomposition","title":"With Cubic B-splines","text":"","category":"section"},{"location":"examples/md_SE/#fixJ-true","page":"Monotone Decomposition","title":"fixJ = true","text":"","category":"section"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Pefrom Monotone Decomposition with Cubic B-splines, where the number of basis functions is chosen by cross-validation for cubic splines.","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"μs = 10.0 .^ (-6:0.1:0)\nD, μmin, errs, σerrs =\n    cv_mono_decomp_cs(x, y, ss = μs, fixJ = true, x0 = x0);\nyhat, yhatnew = cubic_spline(D.workspace.J)(x, y, x0)","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Plot it","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"plot([x, y], [x0, y0], D, yhatnew, prefix_title = \"SE (ℓ = 1, σ = 0.5): \")","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Cross-validation plot","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"cvplot(errs, σerrs, 1.0 * D.workspace.J:D.workspace.J, μs)","category":"page"},{"location":"examples/md_SE/#fixJ-false","page":"Monotone Decomposition","title":"fixJ = false","text":"","category":"section"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Js = 4:50\nD, μmin, errs, σerrs =\n    cv_mono_decomp_cs(x, y, ss = μs, fixJ = false, x0 = x0, Js = Js);\nJ, yhat, yhatnew = cv_cubic_spline(x, y, x0, Js = Js)\nplot([x, y], [x0, y0], D, yhatnew, prefix_title = \"SE (ℓ = 1, σ = 0.5): \")","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"the heatmap of CV-error along the two parameter (J, μ) is as follows,","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"cvplot(errs, σerrs, Js * 1.0, μs)","category":"page"},{"location":"examples/md_SE/#With-Smoothing-Splines","page":"Monotone Decomposition","title":"With Smoothing Splines","text":"","category":"section"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Perform monotone decomposition with smoothing splines, where the tuning parameter λ and μ are tuned by 10-fold cross-validation,","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"D, μmin, μs, errs, σerrs, yhat, yhatnew =\n    cv_mono_decomp_ss(x, y, one_se_rule = true, x0 = x0, tol=1e-3);\nnothing #hide","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"Plot the decomposition,","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"plot([x, y], [x0, y0], D, yhatnew, prefix_title = \"SE (ℓ = 1, σ = 0.5): \")","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"The 10-fold cross-validation curve is","category":"page"},{"location":"examples/md_SE/","page":"Monotone Decomposition","title":"Monotone Decomposition","text":"cvplot(errs, σerrs, μs)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MonotoneDecomposition]\nOrder = [:type, :function]","category":"page"},{"location":"api/#MonotoneDecomposition._optim-Union{Tuple{T}, Tuple{AbstractVector{T}, MonotoneDecomposition.WorkSpaceCS, T}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition._optim","text":"_optim(y::AbstractVector, workspace::WorkSpaceCS, μs::AbstractVector)\n_optim(y::AbstractVector, J::Int, B::AbstractMatrix, H::AbstractMatrix{Int}, μs::AbstractVector)\n\nOptimization for monotone decomposition with cubic B-splines.\n\n_optim(y::AbstractVector, J::Int, B::AbstractMatrix, H::AbstractMatrix{Int}, L::AbstractMatrix, λs::AbstractVector, μs::AbstractVector)\n\nOptimization for monotone decomposition with smoothing splines.\n\n_optim!(y::AbstractVector, J::Int, B::AbstractMatrix, s::Union{Nothing, Real}, γhat::AbstractVector, H::AbstractMatrix{Int}; L, t, λ, μ)\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.benchmarking","page":"API","title":"MonotoneDecomposition.benchmarking","text":"benchmarking(f::String)\n\nRun benchmarking experiments for monotone decomposition on curve f. The candidates of f include:\n\nsimple functions: x^2, x^3, exp(x), sigmoid\nrandom functions generated from Gaussian Process: \"SE1\" \"SE0.1\" \"Mat121\" \"Mat120.1\" \"Mat321\" \"Mat320.1\" \"RQ0.10.5\" \"Periodic0.14\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MonotoneDecomposition.benchmarking_cs","page":"API","title":"MonotoneDecomposition.benchmarking_cs","text":"benchmarking_cs(n, σ, f; figname_cv = nothing, figname_fit = nothing)\n\nRun benchmarking experiments for decomposition with cubic splines on n observations sampled from curve f with noise σ.\n\nOptional Arguments\n\nfigname_cv: if not nothing, the cross-validation error will be plotted and saved to the given path.\nfigname_fit: if not nothing, the fitted curves will be plotted and saved to the given path.\nJs: the candidates of number of basis functions.\nfixJ: whether to use the CV-tuned J from the crossponding cubic spline fitting.\nnfold: the number of folds in cross-validation procedure\none_se_rule: whether to use the one-standard-error rule to select the parameter after cross-validation procedure\nμs: the candidates of tuning parameters for the discrepancy parameter\n\n\n\n\n\n","category":"function"},{"location":"api/#MonotoneDecomposition.benchmarking_ss","page":"API","title":"MonotoneDecomposition.benchmarking_ss","text":"benchmarking_ss(n, σ, f)\n\nRun benchmarking experiments for decomposition with smoothing splines on n observations sampled from curve f with noise σ.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonotoneDecomposition.build_model!-Union{Tuple{T}, Tuple{MonotoneDecomposition.WorkSpaceCS, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.build_model!","text":"build_model!(workspace::WorkSpaceCS, x::AbstractVector{T})\n\nCalculate components that construct the optimization problem for Monotone Decomposition with Cubic splines.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.conf_band_width-Tuple{AbstractMatrix}","page":"API","title":"MonotoneDecomposition.conf_band_width","text":"conf_band_width(CIs::AbstractMatrix)\n\nCalculate width of confidence bands.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.coverage_prob-Tuple{AbstractMatrix, AbstractVector}","page":"API","title":"MonotoneDecomposition.coverage_prob","text":"coverage_prob(CIs::AbstractMatrix, y0::AbstractVector)\n\nCalculate coverage probability given n x 2 CI matrix CIs and true vector y0 of size n.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cv_cubic_spline-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cv_cubic_spline","text":"cv_cubic_spline(x::AbstractVector, y::AbstractVector, xnew::AbstractVector)\n\nB-spline fitting with nfold CV-tuned J from Js.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cv_mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cv_mono_decomp_cs","text":"cv_mono_decomp_cs(x::AbstractVector, y::AbstractVector, xnew::AbstractVector; )\ncv_mono_decomp_cs(x::AbstractVector, y::AbstractVector; fixJ = true)\n\nCross-validation for Monotone Decomposition with Cubic B-splines. Parameters J and s (μ if s_is_μ) are tuned by cross-validation.\n\nif fixJ == true, then J is CV-tuned by the corresponding cubic B-spline fitting\nif fixJ == false, then both J and s would be tuned by cross-validation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cv_mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cv_mono_decomp_cs","text":"cv_mono_decomp_cs(x::AbstractVector, y::AbstractVector)\n\nCross-validation for monotone decomposition with cubic B-splines when the fixed J is CV-tuned by the corresponding cubic B-spline fitting method.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cv_mono_decomp_ss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cv_mono_decomp_ss","text":"cv_mono_decomp_ss(x::AbstractVector, y::AbstractVector)\n\nCross Validation for Monotone Decomposition with Smoothing Splines. with λ tuned by smoothing spline, and then perform golden search for μ.\n\nReturns\n\nD: a MonoDecomp object.\nworkspace: workspace contained some intermediate results\nμmin: the parameter μ that achieve the smallest CV error\nμs: the investigated parameter μ\n\nExample\n\nx, y, x0, y0 = gen_data(100, 0.001, \"SE_0.1\")\nres, workspace = cv_mono_decomp_ss(x, y, one_se_rule = true, figname = \"/tmp/p.png\", tol=1e-3)\nyup = workspace.B * res.γup\nydown = workspace.B * res.γdown\nscatter(x, y)\nscatter!(x, yup)\nscatter!(x, ydown)\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cv_one_se_rule-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cv_one_se_rule","text":"cv_one_se_rule(μs::AbstractVector{T}, σs::AbstractVector{T}; small_is_simple = true)\ncv_one_se_rule(μs::AbstractMatrix{T}, σs::AbstractMatrix{T}; small_is_simple = [true, true])\ncv_one_se_rule2(μs::AbstractMatrix{T}, σs::AbstractMatrix{T}; small_is_simple = [true, true])\n\nReturn the index of parameter(s) (1dim or 2-dim) that minimize the CV error with one standard error rule.\n\nFor 2-dim parameters, cv_one_se_rule2 adopts a grid search for μ+σ while cv_one_se_rule searchs after fixing one optimal parameter.  The potential drawback of cv_one_se_rule2 is that we might fail to determine the simplest model when both parameters are away from the optimal parameters. So we recommend cv_one_se_rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cvfit-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Real, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cvfit","text":"Given `μmax`, and construct μs = (1:nμ) ./ nμ * μmax. If the optimal `μ` near the boundary, double or halve `μmax`.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cvfit_gss-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cvfit_gss","text":"cvfit_gss(x, y, μrange, λs)\n\nFor each λ in λs, perform cvfit(x, y, μrange, λ), and store the current best CV error. Finally, return the smallest one.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cvfit_gss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Real}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.cvfit_gss","text":"cvfit_gss(x, y, μrange, λ; λ_is_μ)\n\nCross-validation by Golden Section Searching μinμrangegivenλ`.\n\nIf λ_is_μ, search λ in μrange given λ (μ)\nNote that one_se_rule is not suitable for the golden section search.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.cvplot","page":"API","title":"MonotoneDecomposition.cvplot","text":"cvplot(sil::String)\ncvplot(μerr::AbstractVector, σerr::Union{Nothing, AbstractVector{T}}, paras::AbstractVector)\ncvplot(μerr::AbstractMatrix, σerr::AbstractMatrix, para1::AbstractVector, para2::AbstractVector)\n\nPlot the cross-validation curves.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonotoneDecomposition.demo_data-Tuple{}","page":"API","title":"MonotoneDecomposition.demo_data","text":"demo_data()\n\nGenerate demo data for illustration. (Figure 6 in the paper)\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.div_into_folds-Tuple{Int64}","page":"API","title":"MonotoneDecomposition.div_into_folds","text":"div_into_folds(N::Int; K = 10, seed = 1234)\n\nEqually divide 1:N into K folds with random seed seed. Specially,\n\nIf seed is negative, it is a non-random division, where the i-th fold would be the i-th equidistant range.\nIf seed = 0, it is a non-random division, where each fold consists of equidistant indexes.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.gen_data-Tuple{Int64, Real, Union{Function, String}}","page":"API","title":"MonotoneDecomposition.gen_data","text":"gen_data(n, σ, f::Union{Function, String}; xmin = -1, xmax = 1, k = 10)\n\nGenerate n data points (xi, yi) from curve f with noise level σ, i.e., yi = f(xi) + N(0, σ^2).\n\nFor f,\n\nif f is a Function, just take y = f(x)\nif f = \"MLP\", it will be a simple neural network with one layer.\notherwise, it accepts the string with format KernelName_Para[_OtherPara] representing some Gaussian Processes, including\nSE, Mat12, Mat32, Mat52, Para: the length scale parameter ℓ\nPoly: Para is the degree parameter p\nRQ: Para is ℓ and OtherPara is α\n\nIt returns four vectors, x, y, x0, y0, where\n\nx, y: pair points of length n.\nx0, y0: true curve without noise, represented by k*n points.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.gen_data_bowman-Tuple{}","page":"API","title":"MonotoneDecomposition.gen_data_bowman","text":"gen_data_bowman()\n\nGenerate Curves for Monotonicity Test used in Bowman et al. (1998)\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.gen_data_ghosal-Tuple{}","page":"API","title":"MonotoneDecomposition.gen_data_ghosal","text":"gen_data_ghosal()\n\nGenerate curves used in Ghosal et al. (2000).\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.gen_mono_data-Tuple{}","page":"API","title":"MonotoneDecomposition.gen_mono_data","text":"gen_mono_data()\n\nGenerate monotonic curves, used for checking type I error under H0. (Table 4 and Figure 5 in the paper)\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.gp-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.gp","text":"gp(x; K)\n\nGenerate a random Gaussian vector with mean zero and covariance matrix Σij = K(xi, xj).\n\nThe candidates of kernel K include SE, Mat12, Mat32, Mat52.\n\nSee also: https://stats.hohoweiya.xyz/2021/12/13/GP/\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.mono_decomp-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.mono_decomp","text":"mono_decomp(y::AbstractVector)\n\nPerform monotone decomposition on vector y, and return yup, ydown.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.mono_decomp_cs","text":"mono_decomp_cs(x::AbstractVector, y::AbstractVector)\n\nMonotone Decomposition with Cubic B-splines by solving an optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.mono_decomp_ss-Union{Tuple{T}, Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector{T}, AbstractVector{T}, AbstractFloat, AbstractFloat}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.mono_decomp_ss","text":"mono_decomp_ss(workspace::WorkSpaceSS, x::AbstractVector{T}, y::AbstractVector{T}, λ::AbstractFloat, μ::AbstractFloat)\n\nMonotone decomposition with smoothing splines.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.mono_test_bootstrap_ss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"API","title":"MonotoneDecomposition.mono_test_bootstrap_ss","text":"mono_test_bootstrap_ss(x, y)\n\nPerform monotonicity test after monotone decomposition with smoothing splines.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.recover-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.recover","text":"recover(Σ)\n\nRecover matrix from the vector-stored Σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotoneDecomposition.smooth_spline-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"MonotoneDecomposition.smooth_spline","text":"smooth_spline(x::AbstractVector, y::AbstractVector, xnew::AbstractVector)\n\nPerform smoothing spline on (x, y), and make predictions on xnew.\n\nReturns: yhat, ynewhat,....\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.plot-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, MonotoneDecomposition.MonoDecomp, AbstractVector}} where T<:(AbstractVector)","page":"API","title":"RecipesBase.plot","text":"plot(obs, truth, D::MonoDecomp, other)\n\nPlot the noised observations, the true curve, and the fitting from monotone decomposition D and other fitting technique.\n\nobs: usually be [x, y]\ntruth: usually be [x0, y0]\nD: a MonoDecomp object\nother: the fitted curve [x0, other] by other method, where x0 is omitted.\n\nA typical usage can be plot([x, y], [x0, y0], D, yhatnew, prefix_title = \"SE (ℓ = 1, σ = 0.5): \")\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{MonotoneDecomposition.MonoDecomp, AbstractVector}","page":"API","title":"StatsAPI.predict","text":"predict(D::MonoDecomp, xnew)\n\nPredict at xnew given decomposition D.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector, AbstractVecOrMat}","page":"API","title":"StatsAPI.predict","text":"predict(W::WorkSpaceSS, xnew::AbstractVector, γhat::AbstractVecOrMat)\npredict(W::WorkSpaceCS, xnew::AbstractVector, γhat::AbstractVecOrMat)\n\nMake multiple predictions at xnew for each column of γhat.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector, AbstractVector, AbstractVector}","page":"API","title":"StatsAPI.predict","text":"predict(W::WorkSpaceSS, xnew::AbstractVector, γup::AbstractVector, γdown::AbstractVector)\npredict(W::WorkSpaceCS, xnew::AbstractVector, γup::AbstractVector, γdown::AbstractVector)\n\nPredict yup and ydown at xnew given workspace W and decomposition coefficients γup and γdown.\n\n\n\n\n\n","category":"method"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"EditURL = \"../../../examples/benchmark_parallel.jl\"","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"Benchmarking","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"using Distributed\n@everywhere using MonotoneDecomposition","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"Candidate functions","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"fs = [\"x^2\" \"x^3\" \"exp(x)\" \"sigmoid\" \"SE_1\" \"SE_0.1\" \"Mat12_1\" \"Mat12_0.1\" \"Mat32_1\" \"Mat32_0.1\" \"RQ_0.1_0.5\" \"Periodic_0.1_4\"]\n\nnrep = 1\nnλ = 2\nnfold = 2\nidxf = 1:2 # run locally\ncompetitor = \"ss_single_lambda\"\nnλ = ifelse(occursin(\"single_lambda\", competitor), 1, nλ)\none_se_rule = false\nresfolder0 = \"/tmp\"\ntimestamp = replace(strip(read(`date -Iseconds`, String)), \":\" => \"_\")\nif length(ARGS) > 0\n    @info \"Use args passed from CLI\"\n    competitor = ARGS[1]\n    resfolder0 = ARGS[2]\n    if !isdir(resfolder0)\n        mkdir(resfolder0)\n    end\n    nλ = parse(Int, ARGS[3])\n    nrep = parse(Int, ARGS[4])\n    nfold = parse(Int, ARGS[5])\n    one_se_rule = parse(Bool, ARGS[6])\n    idxf = 1:length(fs)\n    if length(ARGS) > 6\n        timestamp = AGRS[end] # passed from scripts\n    end\nend\nresfolder = joinpath(resfolder0, \"nrep$nrep-nfold$nfold-nlam$nλ-1se$(one_se_rule)-$competitor-$timestamp\")\nif !isdir(resfolder)\n    mkdir(resfolder)\nend\n@info \"Results are saved into $resfolder\"\n\npmap(\n    f->benchmarking(\n        f;\n        σs = [0.1, 0.2, 0.4, 0.5, 1.0, 1.5, 2.0], # noise level to be surveyed\n        jplot = false, # μerr vs σs\n        nrep = nrep, # NB: for fast auto-generation procedure, only use nrep = 1; in the paper, use nrep = 100\n        competitor = competitor,\n        nfold = nfold, # number of folds\n        one_se_rule = one_se_rule,\n        nλ = nλ, # the number of λ to be searched\n        rλ = 0.5, # the search region of λ, (1-rλ, 1+rλ)*λ\n        resfolder = resfolder,\n        verbose = false,\n        show_progress = f == \"x^3\" # keep one progressbar\n    ),\n    fs[idxf]\n);\nnothing #hide","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"tip: run from command line\njulia examples/benchmark.jl ss_single_lambda /tmp 2 1 2 falseYou can also enable the debug mode to print more internal steps as followsJULIA_DEBUG=MonotoneDecomposition julia examples/benchmark.jl ss_single_lambda /tmp 2 1 2 false","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"summary the results","category":"page"},{"location":"examples/benchmark_parallel/","page":"Benchmarking in Parallel","title":"Benchmarking in Parallel","text":"# MonotoneDecomposition.summary(resfolder = resfolder, format = \"tex\")","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"EditURL = \"../../../examples/benchmark.jl\"","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"Benchmarking","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"using MonotoneDecomposition","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"Candidate functions","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"fs = [\"x^2\" \"x^3\" \"exp(x)\" \"sigmoid\" \"SE_1\" \"SE_0.1\" \"Mat12_1\" \"Mat12_0.1\" \"Mat32_1\" \"Mat32_0.1\" \"RQ_0.1_0.5\" \"Periodic_0.1_4\"]\n\nnrep = 1\nnλ = 2\nnfold = 2\nf = fs[1]\ncompetitor = \"ss_single_lambda\"\nnλ = ifelse(occursin(\"single_lambda\", competitor), 1, nλ)\none_se_rule = false\nresfolder0 = \"/tmp\"\ntimestamp = replace(strip(read(`date -Iseconds`, String)), \":\" => \"_\")\nif length(ARGS) > 0\n    @info \"Use args passed from CLI\"\n    competitor = ARGS[1]\n    resfolder0 = ARGS[2]\n    if !isdir(resfolder0)\n        mkdir(resfolder0)\n    end\n    nλ = parse(Int, ARGS[3])\n    nrep = parse(Int, ARGS[4])\n    nfold = parse(Int, ARGS[5])\n    one_se_rule = parse(Bool, ARGS[6])\n    f = ARGS[7]\n    if length(ARGS) > 7\n        timestamp = replace(strip(ARGS[8]), \":\" => \"_\") # passed from scripts\n    end\nend\nresfolder = joinpath(resfolder0, \"nrep$nrep-nfold$nfold-nlam$nλ-1se$(one_se_rule)-$competitor-$timestamp\")\nif !isdir(resfolder)\n    mkdir(resfolder)\nend\n@info \"Results are saved into $resfolder\"\n\nbenchmarking(\n    f;\n    σs = [0.1, 0.2, 0.4, 0.5, 1.0, 1.5, 2.0], # noise level to be surveyed\n    jplot = false, # μerr vs σs\n    nrep = nrep, # NB: for fast auto-generation procedure, only use nrep = 1; in the paper, use nrep = 100\n    competitor = competitor,\n    nfold = nfold, # number of folds\n    one_se_rule = one_se_rule,\n    nλ = nλ, # the number of λ to be searched\n    rλ = 0.5, # the search region of λ, (1-rλ, 1+rλ)*λ\n    resfolder = resfolder,\n    verbose = false,\n    show_progress = true\n)","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"tip: run from command line\njulia examples/benchmark.jl ss_single_lambda /tmp 2 1 2 falseYou can also enable the debug mode to print more internal steps as followsJULIA_DEBUG=MonotoneDecomposition julia examples/benchmark.jl ss_single_lambda /tmp 2 1 2 false","category":"page"},{"location":"examples/benchmark/","page":"Benchmarking","title":"Benchmarking","text":"tip: summary results\nAfter obtaining results, we can obtain the summarized tex file (used in the manuscript) as follows.MonotoneDecomposition.summary(resfolder = resfolder)","category":"page"},{"location":"#MonotoneDecomposition.jl","page":"Home","title":"MonotoneDecomposition.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MonotoneDecomposition","category":"page"},{"location":"examples/gp/","page":"Gaussian Process","title":"Gaussian Process","text":"EditURL = \"../../../examples/gp.jl\"","category":"page"},{"location":"examples/gp/","page":"Gaussian Process","title":"Gaussian Process","text":"This section shows simulated curves from Gaussian process with various kernels.","category":"page"},{"location":"examples/gp/","page":"Gaussian Process","title":"Gaussian Process","text":"using Random\nusing Plots\nusing LaTeXStrings\nusing MonotoneDecomposition: sigmoid, gp\nfunction plot_functions()\n    n = 100\n    Random.seed!(1)\n    x = sort(rand(n)) * 2 .- 1\n    figsize = (400, 400)\n    fig1 = plot(x, x .^ 3, label = L\"x^3\", ls = :solid, size = figsize, legend = :top)\n    plot!(fig1, x, x .^ 2, label = L\"x^2\", ls = :dash)\n    plot!(fig1, x, exp.(x) .- 1, label = L\"\\exp(x)-1\", ls = :dot)\n    plot!(fig1, x, sigmoid.(x), label = L\"1/(1+\\exp(-5x))\", ls = :dashdot)\n    plot!(fig1, x, sin.(2π * x), label = L\"\\sin(2\\pi x)\", ls = :dashdotdot)\n    # plot(x, gp(x, kernel = \"SE_0.1\"))\n    fig2 = plot(x, gp(x, kernel = \"SE_1\"), label = \"SE_1\", ls = :solid, size = figsize, legend = :topright)\n    plot!(fig2, x, gp(x, kernel = \"SE_0.1\"), label = \"SE_0.1\", ls = :dash)\n    plot!(fig2, x, gp(x, kernel = \"SE_0.5\"), label = \"SE_0.5\", ls = :dot)\n    fig3 = plot(x, gp(x, kernel = \"Mat12_1\"), label = \"Mat12\", ls = :solid, size = figsize, legend = :topleft)\n    plot!(fig3, x, gp(x, kernel = \"Mat32_1\"), label = \"Mat32\", ls = :dash)\n    plot!(fig3, x, gp(x, kernel = \"Mat52_1\"), label = \"Mat52\", ls = :dot)\n    plot!(fig3, x, gp(x, kernel = \"RQ_1_0.5\"), label = \"RQ\", ls = :dashdot)\n    plot!(fig3, x, gp(x, kernel = \"Periodic_1_1\"), ls = :dashdotdot, label = \"Periodic\")\n    return plot(fig1, fig2, fig3, layout = (1, 3), size = (3*figsize[1], figsize[2]) )\n#    savefig(\"~/PGitHub/overleaf/MonoDecomp/figs/funcs.pdf\") # saved for paper\nend","category":"page"},{"location":"examples/gp/","page":"Gaussian Process","title":"Gaussian Process","text":"plot functions generated from Gaussian Process","category":"page"},{"location":"examples/gp/","page":"Gaussian Process","title":"Gaussian Process","text":"plot_functions()","category":"page"}]
}
