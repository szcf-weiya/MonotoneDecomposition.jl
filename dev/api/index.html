<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MonotoneDecomposition.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MonotoneDecomposition.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MonotoneDecomposition.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/gp/">Gaussian Process (GP)</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Monotone Decomposition (MD)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/md_SE/">On A GP Random Function</a></li><li><a class="tocitem" href="../examples/sample_size/">Effects of Sample Size</a></li><li><a class="tocitem" href="../examples/anyJ/">CS vs MDCS under any J</a></li><li><a class="tocitem" href="../examples/anylam/">SS vs MDSS under any λ</a></li></ul></li><li><a class="tocitem" href="../examples/benchmark/">Benchmarking</a></li><li><a class="tocitem" href="../examples/benchmark_parallel/">Benchmarking in Parallel</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition._optim-Union{Tuple{T}, Tuple{AbstractVector{T}, MonotoneDecomposition.WorkSpaceCS, T}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition._optim-Union{Tuple{T}, Tuple{AbstractVector{T}, MonotoneDecomposition.WorkSpaceCS, T}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition._optim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_optim(y::AbstractVector, workspace::WorkSpaceCS, μs::AbstractVector)
_optim(y::AbstractVector, J::Int, B::AbstractMatrix, H::AbstractMatrix{Int}, μs::AbstractVector)</code></pre><p>Optimization for monotone decomposition with cubic B-splines.</p><pre><code class="nohighlight hljs">_optim(y::AbstractVector, J::Int, B::AbstractMatrix, H::AbstractMatrix{Int}, L::AbstractMatrix, λs::AbstractVector, μs::AbstractVector)</code></pre><p>Optimization for monotone decomposition with smoothing splines.</p><pre><code class="nohighlight hljs">_optim!(y::AbstractVector, J::Int, B::AbstractMatrix, s::Union{Nothing, Real}, γhat::AbstractVector, H::AbstractMatrix{Int}; L, t, λ, μ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L602-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.benchmarking" href="#MonotoneDecomposition.benchmarking"><code>MonotoneDecomposition.benchmarking</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">benchmarking(f::String; n = 100, 
                        σs = 0.2:0.2:1,
                        competitor = &quot;ss_single_lambda&quot;)</code></pre><p>Run benchmarking experiments for monotone decomposition on curve <code>f</code>. The candidates of <code>f</code> include:</p><ul><li>simple functions: <code>x^2</code>, <code>x^3</code>, <code>exp(x)</code>, <code>sigmoid</code></li><li>random functions generated from Gaussian Process: <code>SE_1</code> <code>SE_0.1</code> <code>Mat12_1</code> <code>Mat12_0.1</code> <code>Mat32_1</code> <code>Mat32_0.1</code> <code>RQ_0.1_0.5</code> <code>Periodic_0.1_4</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>n::Integer = 100</code>: sample size for the simulated curve</li><li><code>σs::AbstractVector</code>: a vector of noise level to be investigated</li><li><code>competitor::String</code>: a string to indicate the strategy used in monotone decomposition. Possible choices:<ul><li><code>ss_single_lambda</code>: decomposition with smoothing splines <code>ss</code> with the <code>single_lambda</code> strategy</li><li><code>ss_fix_ratio</code>: decomposition with smoothing splines <code>ss</code> with the <code>fix_ratio</code> strategy</li><li><code>ss_grid_search</code>: decomposition with smoothing splines <code>ss</code> with the <code>grid_search</code> strategy</li><li><code>ss_iter_search</code>: decomposition with smoothing splines <code>ss</code> with the <code>iter_search</code> strategy</li><li><code>bspl</code>: decomposition with cubic splines <code>cs</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/benchmarking.jl#L93-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.benchmarking_cs" href="#MonotoneDecomposition.benchmarking_cs"><code>MonotoneDecomposition.benchmarking_cs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">benchmarking_cs(n, σ, f; figname_cv = nothing, figname_fit = nothing)</code></pre><p>Run benchmarking experiments for decomposition with cubic splines on <code>n</code> observations sampled from curve <code>f</code> with noise <code>σ</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>figname_cv</code>: if not <code>nothing</code>, the cross-validation error will be plotted and saved to the given path.</li><li><code>figname_fit</code>: if not <code>nothing</code>, the fitted curves will be plotted and saved to the given path.</li><li><code>Js</code>: the candidates of number of basis functions.</li><li><code>fixJ</code>: whether to use the CV-tuned <code>J</code> from the crossponding cubic spline fitting.</li><li><code>nfold</code>: the number of folds in cross-validation procedure</li><li><code>one_se_rule</code>: whether to use the one-standard-error rule to select the parameter after cross-validation procedure</li><li><code>μs</code>: the candidates of tuning parameters for the discrepancy parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/benchmarking.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.benchmarking_ss" href="#MonotoneDecomposition.benchmarking_ss"><code>MonotoneDecomposition.benchmarking_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">benchmarking_ss(n::Int, σ::Float64, f::Union{Function, String}; 
                    method = &quot;single_lambda&quot;)</code></pre><p>Run benchmarking experiments for decomposition with smoothing splines on <code>n</code> observations sampled from curve <code>f</code> with noise <code>σ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>method::String = &quot;single_lambda&quot;</code>: strategy for decomposition with smoothing spline. Possible choices:<ul><li><code>single_lambda</code></li><li><code>fix_ratio</code></li><li><code>grid_search</code></li><li><code>iter_search</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/benchmarking.jl#L48-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.build_model!-Union{Tuple{T}, Tuple{MonotoneDecomposition.WorkSpaceCS, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.build_model!-Union{Tuple{T}, Tuple{MonotoneDecomposition.WorkSpaceCS, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.build_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_model!(workspace::WorkSpaceCS, x::AbstractVector{T})</code></pre><p>Calculate components that construct the optimization problem for Monotone Decomposition with Cubic splines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1188-L1192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.conf_band_width-Tuple{AbstractMatrix}" href="#MonotoneDecomposition.conf_band_width-Tuple{AbstractMatrix}"><code>MonotoneDecomposition.conf_band_width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conf_band_width(CIs::AbstractMatrix)</code></pre><p>Calculate width of confidence bands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/utils.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.coverage_prob-Tuple{AbstractMatrix, AbstractVector}" href="#MonotoneDecomposition.coverage_prob-Tuple{AbstractMatrix, AbstractVector}"><code>MonotoneDecomposition.coverage_prob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coverage_prob(CIs::AbstractMatrix, y0::AbstractVector)</code></pre><p>Calculate coverage probability given <code>n x 2</code> CI matrix <code>CIs</code> and true vector <code>y0</code> of size <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/utils.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cv_cubic_spline-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cv_cubic_spline-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cv_cubic_spline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_cubic_spline(x::AbstractVector, y::AbstractVector, xnew::AbstractVector)</code></pre><p>B-spline fitting with <code>nfold</code> CV-tuned <code>J</code> from <code>Js</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cv_mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cv_mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cv_mono_decomp_cs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_mono_decomp_cs(x::AbstractVector, y::AbstractVector, xnew::AbstractVector; )
cv_mono_decomp_cs(x::AbstractVector, y::AbstractVector; fixJ = true)</code></pre><p>Cross-validation for Monotone Decomposition with Cubic B-splines. Parameters <code>J</code> and <code>s</code> (<code>μ</code> if <code>s_is_μ</code>) are tuned by cross-validation.</p><ul><li>if <code>fixJ == true</code>, then <code>J</code> is CV-tuned by the corresponding cubic B-spline fitting</li><li>if <code>fixJ == false</code>, then both <code>J</code> and <code>s</code> would be tuned by cross-validation.</li></ul><p><strong>Arguments</strong></p><ul><li><code>figname</code>: if not <code>nothing</code>, then the CV erro figure will be saved to the given name (can include the path)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L313-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cv_mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cv_mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cv_mono_decomp_cs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_mono_decomp_cs(x::AbstractVector, y::AbstractVector)</code></pre><p>Cross-validation for monotone decomposition with cubic B-splines when the fixed <code>J</code> is CV-tuned by the corresponding cubic B-spline fitting method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L382-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cv_mono_decomp_ss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cv_mono_decomp_ss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cv_mono_decomp_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_mono_decomp_ss(x::AbstractVector, y::AbstractVector)</code></pre><p>Cross Validation for Monotone Decomposition with Smoothing Splines. With <code>λ</code> tuned by smoothing spline, and then perform golden search for <code>μ</code>.</p><p><strong>Returns</strong></p><ul><li><code>D</code>: a <code>MonoDecomp</code> object.</li><li><code>workspace</code>: workspace contained some intermediate results</li><li><code>μmin</code>: the parameter <code>μ</code> that achieve the smallest CV error</li><li><code>μs</code>: the investigated parameter <code>μ</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">x, y, x0, y0 = gen_data(100, 0.001, &quot;SE_0.1&quot;)
res, workspace = cv_mono_decomp_ss(x, y, one_se_rule = true, figname = &quot;/tmp/p.png&quot;, tol=1e-3)
yup = workspace.B * res.γup
ydown = workspace.B * res.γdown
scatter(x, y)
scatter!(x, yup)
scatter!(x, ydown)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L419-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cv_one_se_rule-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cv_one_se_rule-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cv_one_se_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_one_se_rule(μs::AbstractVector{T}, σs::AbstractVector{T}; small_is_simple = true)
cv_one_se_rule(μs::AbstractMatrix{T}, σs::AbstractMatrix{T}; small_is_simple = [true, true])
cv_one_se_rule2(μs::AbstractMatrix{T}, σs::AbstractMatrix{T}; small_is_simple = [true, true])</code></pre><p>Return the index of parameter(s) (1dim or 2-dim) that minimize the CV error with one standard error rule.</p><p>For 2-dim parameters, <code>cv_one_se_rule2</code> adopts a grid search for <code>μ+σ</code> while <code>cv_one_se_rule</code> searchs after fixing one optimal parameter.  The potential drawback of <code>cv_one_se_rule2</code> is that we might fail to determine the simplest model when both parameters are away from the optimal parameters. So we recommend <code>cv_one_se_rule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/utils.jl#L61-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cvfit-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Real, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cvfit-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Real, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cvfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Given `μmax`, and construct μs = (1:nμ) ./ nμ * μmax. If the optimal `μ` near the boundary, double or halve `μmax`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1405-L1407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cvfit_gss-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cvfit_gss-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cvfit_gss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvfit_gss(x, y, μrange, λs)</code></pre><p>For each <code>λ</code> in <code>λs</code>, perform <code>cvfit(x, y, μrange, λ)</code>, and store the current best CV error. Finally, return the smallest one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1695-L1699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cvfit_gss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Real}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.cvfit_gss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Real}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.cvfit_gss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvfit_gss(x, y, μrange, λ; λ_is_μ)</code></pre><p>Cross-validation by Golden Section Searching <code>μ</code><code>in</code>μrange<code>given</code>λ`.</p><ul><li>If <code>λ_is_μ</code>, search <code>λ</code> in <code>μrange</code> given <code>λ (μ)</code></li><li>Note that <code>one_se_rule</code> is not suitable for the golden section search.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1589-L1596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.cvplot" href="#MonotoneDecomposition.cvplot"><code>MonotoneDecomposition.cvplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cvplot(sil::String)
cvplot(μerr::AbstractVector, σerr::Union{Nothing, AbstractVector{T}}, paras::AbstractVector)
cvplot(μerr::AbstractMatrix, σerr::AbstractMatrix, para1::AbstractVector, para2::AbstractVector)</code></pre><p>Plot the cross-validation curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1207-L1213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.demo_data-Tuple{}" href="#MonotoneDecomposition.demo_data-Tuple{}"><code>MonotoneDecomposition.demo_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">demo_data()</code></pre><p>Generate demo data for illustration. (Figure 6 in the paper)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_test.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.div_into_folds-Tuple{Int64}" href="#MonotoneDecomposition.div_into_folds-Tuple{Int64}"><code>MonotoneDecomposition.div_into_folds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_into_folds(N::Int; K = 10, seed = 1234)</code></pre><p>Equally divide <code>1:N</code> into <code>K</code> folds with random seed <code>seed</code>. Specially,</p><ul><li>If <code>seed</code> is negative, it is a non-random division, where the <code>i</code>-th fold would be the <code>i</code>-th equidistant range.</li><li>If <code>seed = 0</code>, it is a non-random division, where each fold consists of equidistant indexes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/utils.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.gen_data-Tuple{Int64, Union{Nothing, Real}, Union{Function, String}}" href="#MonotoneDecomposition.gen_data-Tuple{Int64, Union{Nothing, Real}, Union{Function, String}}"><code>MonotoneDecomposition.gen_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_data(n::Int, σ::Union{Real, Nothing}, f::Union{Function, String}; xmin = -1, xmax = 1, k = 10)</code></pre><p>Generate <code>n</code> data points <code>(xi, yi)</code> from curve <code>f</code> with noise level <code>σ</code>, i.e., <code>yi = f(xi) + N(0, σ^2)</code>.</p><p><strong>Arguments</strong></p><ul><li><p>for <code>f</code></p><ul><li>if <code>f</code> is a <code>Function</code>, just take <code>y = f(x)</code></li><li>if <code>f = &quot;MLP&quot;</code>, it will be a simple neural network with one layer.</li><li>otherwise, it accepts the string with format <code>KernelName_Para[_OtherPara]</code> representing some Gaussian Processes, including<ul><li><code>SE</code>, <code>Mat12</code>, <code>Mat32</code>, <code>Mat52</code>, <code>Para</code>: the length scale parameter <code>ℓ</code></li><li><code>Poly</code>: <code>Para</code> is the degree parameter <code>p</code></li><li><code>RQ</code>: <code>Para</code> is <code>ℓ</code> and <code>OtherPara</code> is <code>α</code></li></ul></li></ul></li><li><p>for <code>σ</code>: the noise level</p><ul><li>if <code>σ</code> is <code>nothing</code>, then <code>σ</code> is calculated to achieve given signal-to-noise ratio (<code>snr</code>)</li></ul></li><li><p>if <code>seed</code> is not <code>nothing</code>, it ensures the same random function from Gaussian process, but it does not influence the random noises.</p></li></ul><p><strong>Returns</strong></p><p>It returns four vectors, <code>x, y, x0, y0</code>, where</p><ul><li><code>x, y</code>: pair points of length <code>n</code>.</li><li><code>x0, y0</code>: true curve without noise, represented by <code>k*n</code> points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/genfunc.jl#L9-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.gen_data_bowman-Tuple{}" href="#MonotoneDecomposition.gen_data_bowman-Tuple{}"><code>MonotoneDecomposition.gen_data_bowman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_data_bowman()</code></pre><p>Generate Curves for Monotonicity Test used in Bowman et al. (1998)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_test.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.gen_data_ghosal-Tuple{}" href="#MonotoneDecomposition.gen_data_ghosal-Tuple{}"><code>MonotoneDecomposition.gen_data_ghosal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_data_ghosal()</code></pre><p>Generate curves used in Ghosal et al. (2000).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_test.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.gen_mono_data-Tuple{}" href="#MonotoneDecomposition.gen_mono_data-Tuple{}"><code>MonotoneDecomposition.gen_mono_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_mono_data()</code></pre><p>Generate monotonic curves, used for checking type I error under H0. (Table 4 and Figure 5 in the paper)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_test.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.gp-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.gp-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.gp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gp(x; K)</code></pre><p>Generate a random Gaussian vector with mean zero and covariance matrix <code>Σij = K(xi, xj)</code>.</p><p>The candidates of kernel <code>K</code> include SE, Mat12, Mat32, Mat52.</p><p>See also: <a href="https://stats.hohoweiya.xyz/2021/12/13/GP/">https://stats.hohoweiya.xyz/2021/12/13/GP/</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/genfunc.jl#L104-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.mono_decomp-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.mono_decomp-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.mono_decomp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mono_decomp(y::AbstractVector)</code></pre><p>Perform monotone decomposition on vector <code>y</code>, and return <code>yup</code>, <code>ydown</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.mono_decomp_cs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.mono_decomp_cs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mono_decomp_cs(x::AbstractVector, y::AbstractVector)</code></pre><p>Monotone Decomposition with Cubic B-splines by solving an optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.mono_decomp_ss-Union{Tuple{T}, Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector{T}, AbstractVector{T}, AbstractFloat, AbstractFloat}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.mono_decomp_ss-Union{Tuple{T}, Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector{T}, AbstractVector{T}, AbstractFloat, AbstractFloat}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.mono_decomp_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mono_decomp_ss(workspace::WorkSpaceSS, x::AbstractVector{T}, y::AbstractVector{T}, λ::AbstractFloat, μ::AbstractFloat)</code></pre><p>Monotone decomposition with smoothing splines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L998-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.mono_test_bootstrap_ss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#MonotoneDecomposition.mono_test_bootstrap_ss-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>MonotoneDecomposition.mono_test_bootstrap_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mono_test_bootstrap_ss(x, y)</code></pre><p>Perform monotonicity test after monotone decomposition with smoothing splines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_test.jl#L459-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.recover-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.recover-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.recover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recover(Σ)</code></pre><p>Recover matrix from the vector-stored <code>Σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MonotoneDecomposition.smooth_spline-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MonotoneDecomposition.smooth_spline-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MonotoneDecomposition.smooth_spline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth_spline(x::AbstractVector, y::AbstractVector, xnew::AbstractVector)</code></pre><p>Perform smoothing spline on <code>(x, y)</code>, and make predictions on <code>xnew</code>.</p><p>Returns: <code>yhat</code>, <code>ynewhat</code>,....</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L151-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, MonotoneDecomposition.MonoDecomp, AbstractVector}} where T&lt;:(AbstractVector)" href="#RecipesBase.plot-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, MonotoneDecomposition.MonoDecomp, AbstractVector}} where T&lt;:(AbstractVector)"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(obs, truth, D::MonoDecomp, other)</code></pre><p>Plot the noised observations, the true curve, and the fitting from monotone decomposition <code>D</code> and <code>other</code> fitting technique.</p><ul><li><code>obs</code>: usually be <code>[x, y]</code></li><li><code>truth</code>: usually be <code>[x0, y0]</code></li><li><code>D</code>: a <code>MonoDecomp</code> object</li><li><code>other</code>: the fitted curve <code>[x0, other]</code> by other method, where <code>x0</code> is omitted.</li></ul><p>A typical usage can be <code>plot([x, y], [x0, y0], D, yhatnew, prefix_title = &quot;SE (ℓ = 1, σ = 0.5): &quot;)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1114-L1125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{MonotoneDecomposition.MonoDecomp, AbstractVector}" href="#StatsAPI.predict-Tuple{MonotoneDecomposition.MonoDecomp, AbstractVector}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(D::MonoDecomp, xnew)</code></pre><p>Predict at <code>xnew</code> given decomposition <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1031-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector, AbstractVecOrMat}" href="#StatsAPI.predict-Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector, AbstractVecOrMat}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(W::WorkSpaceSS, xnew::AbstractVector, γhat::AbstractVecOrMat)
predict(W::WorkSpaceCS, xnew::AbstractVector, γhat::AbstractVecOrMat)</code></pre><p>Make multiple predictions at <code>xnew</code> for each column of <code>γhat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1063-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector, AbstractVector, AbstractVector}" href="#StatsAPI.predict-Tuple{MonotoneDecomposition.WorkSpaceSS, AbstractVector, AbstractVector, AbstractVector}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(W::WorkSpaceSS, xnew::AbstractVector, γup::AbstractVector, γdown::AbstractVector)
predict(W::WorkSpaceCS, xnew::AbstractVector, γup::AbstractVector, γdown::AbstractVector)</code></pre><p>Predict <code>yup</code> and <code>ydown</code> at <code>xnew</code> given workspace <code>W</code> and decomposition coefficients <code>γup</code> and <code>γdown</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/szcf-weiya/MonotoneDecomposition.jl/blob/7353512ab8f169ee371a9fe83e80b0c7e2e55f45/src/mono_decomp.jl#L1041-L1046">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/benchmark_parallel/">« Benchmarking in Parallel</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 November 2025 10:46">Monday 24 November 2025</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
